(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{365:function(t,a,r){"use strict";r.r(a);var s=r(25),_=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"css-矩阵"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#css-矩阵"}},[t._v("#")]),t._v(" CSS 矩阵")]),t._v(" "),r("h2",{attrs:{id:"矩阵数学概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#矩阵数学概念"}},[t._v("#")]),t._v(" 矩阵数学概念")]),t._v(" "),r("p",[t._v("在数学中，矩阵（Matrix）是⼀个按照⻓⽅阵列排列的复数或实数集合，最早来⾃于⽅程组的系数及常数所构成的⽅阵。")]),t._v(" "),r("p",[t._v("矩阵是⾼等代数学中的常⻅⼯具，也常⻅于统计分析等应⽤数学学科中。在物理学中，矩阵于电路学、⼒学、光学和量⼦物理中都有应⽤；计算机科学中，三维动画制作也需要⽤到矩阵。矩阵的运算是数值分析领域的重要问题。由 m × n 个数aij排成的m⾏n列的数表称为m⾏n列的矩阵，简称m × n矩阵。这m×n 个数称为矩阵A的元素，简称为元")]),t._v(" "),r("h2",{attrs:{id:"计算规则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#计算规则"}},[t._v("#")]),t._v(" 计算规则")]),t._v(" "),r("p",[t._v("矩阵第m⾏与第n列交叉位置的那个值，等于第⼀个矩阵第m⾏与第⼆个矩阵第n列，对应位置的每个值的乘积之和。线性代数是向量计算的基础，很多重要的数学模型都要⽤到向量计算。矩阵的本质就是线性⽅程式，两者是⼀⼀对应关系。如果从线性⽅程式的⻆度，理解矩阵乘法就毫⽆难度")]),t._v(" "),r("p",[t._v("参考 "),r("a",{attrs:{href:"https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5",target:"_blank",rel:"noopener noreferrer"}},[t._v("百度百科 矩阵"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"css-中矩阵的应用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#css-中矩阵的应用"}},[t._v("#")]),t._v(" CSS 中矩阵的应用")]),t._v(" "),r("p",[t._v("matrix()和 matrix3d()")]),t._v(" "),r("h3",{attrs:{id:"_2d-3d矩阵应⽤"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2d-3d矩阵应⽤"}},[t._v("#")]),t._v(" 2D & 3D矩阵应⽤")]),t._v(" "),r("p",[t._v("前者是元素2D平⾯的移动变换(transform)，后者则是3D变换。2D变换矩阵为 "),r("code",[t._v("3*3")]),t._v(", 3D变换则是 "),r("code",[t._v("4*4")]),t._v(" 的矩阵")]),t._v(" "),r("h3",{attrs:{id:"transform-原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#transform-原理"}},[t._v("#")]),t._v(" transform 原理")]),t._v(" "),r("ul",[r("li",[t._v("skew")]),t._v(" "),r("li",[t._v("scale")]),t._v(" "),r("li",[t._v("rotate")]),t._v(" "),r("li",[t._v("translate")])]),t._v(" "),r("p",[r("code",[t._v("transform: matrix(a,b,c,d,e,f)")])]),t._v(" "),r("p",[t._v("⽆论是旋转还是拉伸什么的，本质上都是应⽤的matrix()⽅法实现的（修改matrix()⽅法固定⼏个值），只是类似于transform:rotate这种表现形式，我们更容易理解，记忆与上⼿")]),t._v(" "),r("p",[r("code",[t._v("transform-origin")])]),t._v(" "),r("p",[t._v("通过transform-origin属性进⾏设置的时候，矩阵相关计算也随之发⽣改变。实际图形效果上就是，旋转拉伸的中⼼点变了")]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[t._v("总结")]),t._v(" "),r("p",[t._v("少点套路，多点真诚，底层就是 matrix 实现的 transform，肯定 martrix 性能更好，可以对 transform 属性进行优化")])]),t._v(" "),r("h2",{attrs:{id:"更多的应用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#更多的应用场景"}},[t._v("#")]),t._v(" 更多的应用场景")]),t._v(" "),r("ul",[r("li",[t._v("SVG "),r("code",[t._v('transform="matrix(a b c d e f)"')])]),t._v(" "),r("li",[t._v("Canvas "),r("code",[t._v("context.transform(2,0,0,2,150,150)")])]),t._v(" "),r("li",[t._v("WebGL 投影，变化，视图变化")]),t._v(" "),r("li",[t._v("CSS 3D "),r("code",[t._v("matrix3d")])])])])}),[],!1,null,null,null);a.default=_.exports}}]);